# Android性能优化之内存优化

https://juejin.im/post/5e72b2d151882549236f9cb8

# 深入探索 Android 内存优化（炼狱级别）

https://juejin.im/post/5e780257f265da575209652c

# 前言

### 成为一名优秀的Android开发，需要一份完备的[知识体系](https://github.com/JsonChao/Awesome-Android-Exercise)，在这里，让我们一起成长为自己所想的那样~。

```
Tips：本篇是《深入探索Android内存优化》的基础篇，如果没有掌握Android内存优化的同学建议系统学习一遍。
复制代码
```

众所周知，内存优化可以说是性能优化中最重要的优化点之一，可以说，**如果你没有掌握系统的内存优化方案，就不能说你对Android的性能优化有过多的研究与探索**。本篇，笔者将带领大家一起来系统地学习Android中的内存优化。

可能有不少读者都知道，在内存管理上，JVM拥有垃圾内存回收的机制，自身会在虚拟机层面自动分配和释放内存，因此不需要像使用C/C++一样在代码中分配和释放某一块内存。Android系统的内存管理类似于JVM，通过new关键字来为对象分配内存，内存的释放由GC来回收。并且Android系统在内存管理上有一个 **Generational Heap Memory模型**，当内存达到某一个阈值时，系统会根据不同的规则自动释放可以释放的内存。即便有了内存管理机制，但是，如果不合理地使用内存，也会造成一系列的性能问题，比如 **内存泄漏、内存抖动、短时间内分配大量的内存对象** 等等。下面，我就先来谈谈Android的内存管理机制。

# 第4章 App内存优化

## 4-2 内存优化介绍及工具选择

> 本章从原理开始讲起，首先介绍Java及Android的内存管理机制，接下来手把手带领大家进行内存抖动、泄露的解决实战，同时通过ArtHook的方式优雅解检测出App所有不合理的图片。

### 4.2.1 背景介绍

* 内存是大问题但缺乏关注
* 压死骆驼的最后一根稻草

### 4.2.2 内存问题

* 内存抖动：锯齿状、GC导致卡顿
* 内存泄漏：可用内存减少、频繁GC
* 内存溢出：OOM、程序异常

### 4.2.3 工具选择

* Memory Profiler
  * 实时图表展示应用内存使用量
  * 识别内存泄漏、抖动等
  * 提供捕获堆转储、强制GC以及跟踪内存分配的能力
* Memory Analyzer
  * 强大的Java Heap分析工具，查找内存泄漏及内存占用
  * 生成整体报告、分析问题等
  * 线下深入使用
* LeakCanary
  * 自动内存泄漏检测
  * https://github.com/square/leakcanary
  * 线下集成

## 4-3 Android内存管理机制

### 4.3.1 Java 内存管理机制

### 4.3.1.1 Java内存分配

* #### 方法区

* 虚拟机栈

* 本地方法栈

* 堆

* 程序计数器具

#### 4.3.1.2 Java内存回收算法

* a、标记-清除算法
  * 标记出所有需要回收的对象
  * 统一回收所有被标记的对象
  * 缺点：
    * 标记和清除效率不高
    * 产生大量不连续的内存碎片
* b、复制算法
  * 将内存划分为大小相等的两块
  * 一块内存用完之后复制存活对象到另一块
  * 清理另一块内存
  * 优缺点：
    * 实现简单、运行高效
    * 浪费一半空间，代价大
* c、标记-整理算法
  * 标记过程与“标记-清除”算法一样
  * 存活对象往一端移动
  * 清理其余内存
  * 优缺点：
    * 避免标记-清理导致的内存碎片
    * 避免复制算法的空间浪费
* d、分代收集算法
  * 结合多种收集算法优势
  * 新生代对象存活率低：采用标记-复制
  * 老年代对象存活率高：采用标记-整理

### 4.3.2 Android内存管理机制

* 内存弹性分配，分配值与最大值受具体设备影响
* OOM场景：内存真正不足、可用内存不足

### 4.3.2.1 Dalvik与Art区别

* #### Dalvik仅固定一种回收算法

* Art回收算法可运行期选择

* Art具备内存整理能力，减少内存空洞

#### 4.3.2.2 Low Memory Killer

* 进程分类
  * 前台进程
  * 可见进程
  * 服务进程
  * 后台进程
  * 空进程
* 回收收益

## 4-4 内存抖动解决实战

**内存抖动介绍**

* 定义：内存频繁分配和回收导致内存不稳定
* 表现：频繁GC、内存曲线呈锯齿状
* 危害：导致卡顿、OOM

**内存抖动导致OOM**

* 频繁创建对象，导致内存不足及碎片（内存不连续）
* 不连续的内存片无法被分配，导致OOM

**内存抖动解决实战**

* 使用Memory Profiler初步排查
* 使用Memory Profiler或CPU Profiler结合代码排查

**内存抖动解决技巧**

找循环或者频繁调用的地方

## 4-5 内存泄露解决实战

### 4.5.1 内存泄漏介绍

* 定义：内存中存在已经没有用的对象
* 表现：内存抖动、可用内存逐渐变少
* 危害：内存不足、GC频繁、OOM

### 4.5.2 Memory Analyzer

* https://www.eclipse.org/mat/downloads.php
* 转换：hprof-conv 原文件路径 转换后文件路径

### 4.5.2 内存泄漏解决实战

* 使用Memory Profiler初步观察
  * 文件转换：D:\Program\Android\Sdk\platform-tools> hprof-conv D:\learn\Android\Performance\memory-20200430T152256.hprof D:\learn\
    Android\Performance\memory-20200430T152256_transed.hprof
* 通过Memory Analyzer结合代码确认
  * File → Open File → memory-20200430T152256_transed.hprof

## 4-6 全面理解MAT

MAT工具的全面理解及使用

## 4-7 ARTHook优雅检测不合理图片

### 4.7.1 Bitmap内存模型

* API10之前Bitmap自身在Dalvik Heap中，像素在Native
* API10之后像素也被放在Dalvik Heap中
* API26之后像素在Native

**获取Bitmap占用内存**

* getByteCount
* 宽 * 高 * 一像素占用内存

### 4.7.2 常规方式

* 背景：图片对内存优化至关重要、图片宽高大于控件宽高
* 实现：继承ImageView，覆写实现计算大小
* 缺点：
  * 侵入性强
  * 不通用

### 4.7.3 ARTHook介绍

* 挂钩，将额外的代码钩住原有方法
  * 运行时插桩
  * 性能分析

#### 4.7.4.1 Epic简介

* Epic是一个虚拟机层面，以Java Method为粒度的运行时Hook框架
* 支持Android4.0 ~ 10
* https://github.com/tiann/epic

#### 4.7.4.2 Epic使用

* compile 'me.weishu:epic:0.6.0'
* 继承XC_MethodHook，实现相应逻辑
* 注入Hook：DexposedBridge.findAndHookMethod

#### 4.7.4.3 ARTHook实现

* 无侵入性
* 通用性强
* 兼容问题大，开源方案不能带到线上环境

### 4.7.4 总结

* Bitmap内存模型
* 优雅检测不合理图片的方式
* ARTHook的理解及使用

## 4-8 线上内存监控方案

> 目录：
>
> 常规方式
>
> LeakCanary定制
>
> 线上监控完整方案

### 4.8.1 常规实现一

设定场景线上Dump：Debug.dumpHprofData()

**常规实现流程**

超过最大内存80%   →   内存Dump

​												↓

MAT手动分析          ←    回收文件（WiFi上传）

**方案一总结**

* Dump文件太大，和对象数正相关，可裁剪（通过NativeHook的方式）
* 上传失败率高、分析困难
* 配合一定策略，有一定效果

### 4.8.2 常规实现二

* LeakCanary带到线上
* 预设泄漏怀疑点
* 发现泄漏回传

**方案二总结**

1. 不合适所有情况，必须预设怀疑点
2. 分析比较耗时，也容易OOM

**LeakCanary原理**

* 监控生命周期，onDestroy添加RefWatcher检测
* 二次确认断定发生内存泄漏
* 分析泄漏，找引用链
* 监控组件+分析组件

**LeakCanary定制**

1. 预设怀疑点 → 自动找怀疑点
2. 分析泄漏链路慢  → 分析Retain size大的对象
3. 分析OOM → 对象裁剪，不全部加载到内存

### 4.8.3 线上监控完整方案

* 待机内存、重点模块内存、OOM率
* 整体及重点模块GC次数、GC时间
* 增强的LeakCanary自动化内存泄漏分析

## 4-9 内存优化技巧总结

### 优化大方向

* 内存泄漏
* 内存抖动
* Bitmap

### 优化细节

* LargeHeap属性
* onTrimMemory
* 使用优化过的集合：SparseArray
* 谨慎使用SharedPreference
* 谨慎使用外部库
* 业务架构设计合理

## 4-10 内存优化模拟面试

1. 你们内存优化项目的过程是怎么做的？
   * 分析现状、确认问题
   * 针对性优化
   * 效率提升（做了哪些工作提升了效率，比如编写了一系列优化解决方案的文档分享给大家）
2. 你做了内存优化最大的感受是什么？
   * 磨刀不误砍柴工
     * 首先系统学习谷歌官方文档以及Memory Profiler、MAT工具的使用，将这些工具熟练使用之后，然后在项目当中遇到了一些问题，我们就能迅速的排查定位进行解决
   * 技术优化必须结合业务代码
     * 梳理是否存在多个图片库，因为他们的内存缓存不共用，会导致整个项目bitmap内存使用量非常高
   * 系统化完善解决方案
     * 突破线下使用的限制，安卓端采集数据上报服务器，便于Bug、crash跟踪人员进行一系列问题的解决

3. 如何检测所有不合理的地方？
   * ARTHook
   * 重点强调它与其他方案的区别
     * 讲一下演进过程，最初的设计是继承ImageView，覆写它的onDraw方法，但是呢，在推广过程中，很多开发人员不愿意接受，因为很多ImageView之前已经写好了，现在让其替换，这个成本是很高的，后来呢，我们就思考，有没有一种方案是免替换的，最终我们找到了ARTHook这个方案

